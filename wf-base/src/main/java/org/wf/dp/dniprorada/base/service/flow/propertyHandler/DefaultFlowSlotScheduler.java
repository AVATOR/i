package org.wf.dp.dniprorada.base.service.flow.propertyHandler;

import org.joda.time.DateTime;
import org.joda.time.Duration;
import org.quartz.CronExpression;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Required;
import org.wf.dp.dniprorada.base.model.FlowSlot;
import org.wf.dp.dniprorada.base.util.JsonDateTimeDeserializer;
import org.wf.dp.dniprorada.base.util.JsonDateTimeSerializer;
import org.wf.dp.dniprorada.base.util.JsonRestUtils;

import java.text.ParseException;
import java.util.*;

/**
 * User: goodg_000
 * Date: 29.06.2015
 * Time: 18:57
 */
public class DefaultFlowSlotScheduler extends BaseFlowSlotScheduler {

   protected static final Logger LOG = LoggerFactory.getLogger(DefaultFlowSlotScheduler.class);

   private int maxGeneratedSlotsCount;

   private String defaultFlowSlotName;

   public int getMaxGeneratedSlotsCount() {
      return maxGeneratedSlotsCount;
   }
   @Required
   public void setMaxGeneratedSlotsCount(int maxGeneratedSlotsCount) {
      this.maxGeneratedSlotsCount = maxGeneratedSlotsCount;
   }

   public String getDefaultFlowSlotName() {
      return defaultFlowSlotName;
   }
   @Required
   public void setDefaultFlowSlotName(String defaultFlowSlotName) {
      this.defaultFlowSlotName = defaultFlowSlotName;
   }

   @Override
   public List<FlowSlot> generateObjects(String sData) {

      Map<String, String> configuration = JsonRestUtils.readObject(sData, Map.class);

      prepareInterval();

      TreeMap<DateTime, FlowSlot> res = new TreeMap<>();

      for (Map.Entry<String, String> entry : configuration.entrySet()) {
         DateTime currDateTime = startDate;
         String cronExpressionString = entry.getKey();
         String slotDuration = entry.getValue();

         CronExpression cronExpression;
         try {
            cronExpression = new CronExpression(cronExpressionString);
         } catch (ParseException e) {
            throw new RuntimeException(e);
         }

         int generatedSlotsCount = 0;
         while (currDateTime.isBefore(endDate)) {
            currDateTime = new DateTime(cronExpression.getNextValidTimeAfter(currDateTime.toDate()));
            if (endDate.compareTo(currDateTime) <= 0) {
               break;
            }

            if (res.containsKey(currDateTime)) {
               if (LOG.isDebugEnabled()) {
                  LOG.debug(String.format(
                          "Date %s generated by expression '%s' already generated by previous expressions. " +
                                  "Keeping first generated slot.", currDateTime, cronExpression));
               }
               continue;
            }

            if (generatedSlotsCount >= maxGeneratedSlotsCount) {
               throw new IllegalStateException("Can't generate more then " + maxGeneratedSlotsCount + " slots!");
            }

            FlowSlot slot = new FlowSlot();
            slot.setName(defaultFlowSlotName);
            slot.setsDate(currDateTime);
            slot.setsDuration(slotDuration);
            res.put(currDateTime, slot);
            generatedSlotsCount++;
         }
      }


      return new ArrayList<>(res.values());
   }

}
